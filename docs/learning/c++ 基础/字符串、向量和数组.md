本章将介绍两种重要的标准库类型 `string` 和 `vector`：
- string：表示可变长的字符序列
- vector：存放某种给定类型对象的可变长序列
- 数组：数组的实现与硬件密切相关，string 和 vector 都是对它的某种抽象，但其灵活性稍有不足
- 迭代器：是 string 和 vector 的配套类型，常被用于访问 string 中的字符或 vector 中的元素
## 命名空间的 using 声明
作用域操作符（::）的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。
```cpp
#include <iostream>
std::string a; // 使用命名空间 std 的中名字 string
```
### using 声明（using declaration）
- 形式：`using namespace::name`
- 无须专门的前缀（namespace::name）也能使用所需的名字
- 每个名字都需要独立的 using 声明：
  ```cpp
  #include <iostream>
  // 一行可以放多条 using 声明语句，但每个名字都必须有自己的 using 声明语句，以分号结束
  using std::cout; using std::endl; 
  using std::string;
  int main()
  {
      string a = "str";
      cout << a << endl;
      return 1;
  }
  ```
### 头文件不应包含 using 声明语句
头文件的内容会被拷贝到所有包含它的文件中去，如果头文件里有某个 using 声明，那么每个使用该头文件的文件都会有这个声明。由于不经意间包含了一些名字，反而可以产生始料未及的名字冲突。
## 标准库类型 string
使用 `string` 类型必须包含 string 头文件，作为标准库的一部分，string 定义在命名空间 std 中：
```cpp
#include <string>
using std::string;
```
### 定义和初始化
| 初始化方式          | 含义                                                    |
| ------------------- | :------------------------------------------------------ |
| string s1           | 默认初始化，s1是一个空字符串                            |
| string s2(s1)       | s2是s1的副本                                            |
| string s2 = s1      | 等价于 s2(s1)                                           |
| string s3("value)   | s3是字面值"value"的副本，除了字面值最后的那个空字符串外 |
| string s3 = "value" | 等价于s3("value")                                       |
| string s4(n,'c')    | 把s4初始化为由连续n个字符'c'组成的串                    |
直接初始化和拷贝初始化：
- 拷贝初始化（copy initialization）：使用等号（=）初始化一个变量
- 直接初始化（direct initialization）：不使用等号初始化
### string 对象上的操作

| 操作             | 含义                                       |
| ---------------- | :----------------------------------------- |
| `os << s`        | 将s写到输出流os当中，返回os                |
| `is >> s`        | 从输入流is读取字符赋给s，返回is            |
| `getline(is, s)` | 从输入流is读取一行赋给s，返回is            |
| `s.empty()`      | s为空返回true，否则返回false               |
| `s.size()`       | 返回s中字符的个数                          |
| `s[n]`           | 返回s中第n个字符的引用                     |
| `s1 + s2`        | 返回s1和s2连接后的结果                     |
| `s1 = s2`        | 用s2的副本替代s1原来的字符                 |
| `s1 == s2`       | 判断s1和s2所含的字符是否完全一样           |
| `s1 != s2`       | 对大小写敏感                               |
| `<, <=, >, >=`   | 利用字符在字典中的顺序进行比较，大小写敏感 |
读写 string 对象
- 执行读写操作时，`string` 对象会自动忽略开头的空白并从第一个真的的字符开始读起，知道遇见下一处空白：
  ```cpp
  string s;
  cin >> s;
  cout << s << std::endl;
  ```
  如果程序输入是“    HELLO WORLD    ”，则输出将是“HELLO”，输出结果没有包含任何空格。

  和内置类型的输入输出一样，string 对象的此类操作也是返回操作符左侧的运算对象作为其结果：
  ```cpp
  string s1, s2;
  cin >> s1 >> s2;
  cout << s1 << s2 << std::endl;
  ```
  如果程序输入是“    HELLO WORLD    ”，则输出将是“HELLOWORLD”。
- 读取未知数量的 string 对象：
  ```cpp
  string s, tmp;
  while (cin >> tmp)
  {
      s += tmp;
  }
  cout << s << std::endl;
  ```

- 如果希望在最终的字符串中保留输入时的空格符，这时应使用 `getline`
  ```cpp
  string s, tmp;
  while (std::getline(std::cin, tmp))
  {
      s += tmp;
      s += "\n";
  }

  std::cout << s << std::endl;
  ```
  `getline` 函数接收一个输入流和一个 `string` 对象，函数从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来），然后把读取的内容存入 `string` 对象中（注意不存换行符）。

string 的 empty 和 size 操作：
- empty：`string` 的一个成员函数，根据 `string` 对象是否为空返回一个对应的布尔值。
- size：返回 string 对象的长度
- string::size_type：`string` 类及其他大多数标准库类型定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性，`string::size_type` 即是其中的一种。`string::size_type` 是一个无符号类型的值而且足够存放下任何 `string` 对象的大小。所有用于存放 `string` 类的 `size` 函数返回值的变量，都应该是 `string::size_type` 类型的。
  ::: tip
  如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。如果一条表达式中已经有了 `size` 函数，就不要再使用 `int`，这样可以避免混用 `int` 和 `unsigned` 可能带来的问题。
  :::
比较 string 对象
- 相等性运算符（== 和 !=）：比较两个 `string` 对象是否长度相等且所包含的字符也全部相同。
- <、<=、>、>=：
  - 如果两个 `string` 对象的长度不通，而且较短 `string` 对象的每个字符都与较长 `string` 对象对应位置上的字符相同，就说较短 `string` 对象小于较长 `string` 对象。
  - 如果 string 对象在某些对应位置上不一致，则 string 对象比较的结果其实就是 string 对象中第一对相异字符比较的结果。
字面值和 string 对象相加

标准库允许将字符字面值与字符串字面值转化成 string 对象，所以在需要 string 对象的地方就可以使用这两种字面量来代替。
```cpp
string s;
s+='a';
s+='b';
std::cout << s << std::endl;
```
::: tip
当把 string 对象和字符字面量及字符串字面量混在一条语句中使用时，必须确保加法运算符（+）的两侧运算对象至少有一个是 string 对象。
```cpp
string s = "";
string s1 = s + "hello" + "world"; // 正确
string s2 = "hello" + "world" + 2; // 错误
```
切记：c++ 语言中的字符串字面量并不是标准库类型 string 的对象，字符串字面量与 string 对象是不同的类型。
:::
### 处理 string 对象中的字符
cctype 头文件中的函数
|   函数   |          含义          |
| :------: | :--------------------: |
| isalnum  |       数字或字母       |
| isalpha  |          数字          |
| isdigit  |          字母          |
| isxdigit |      十六进制数字      |
| isprint  | 可打印：空格、可使形式 |
| isspace  |     空格、空白字符     |
| isgraph  |      非空白可打印      |
| iscntrl  |        控制字符        |
| ispunct  |        标点符号        |
| islower  |        小写字母        |
| isupper  |        大写字母        |
| tolower  |                        |
| toupper  |                        |
::: tip
C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 `name.h`，C++ 则将这些文件命名为 `cname`。 
`cctype` 头文件和 `ctype.h` 头文件的内容是一样的，只不过从命名规范上更复合 C++ 语言的要求。在 `cname` 头文件定义的名字从属于命名空间 `std`，而定义在 `name.h` 中的则不然。
:::
处理每个字符？使用基于范围的 for 语句
```cpp
for (auto i : "abcd")
{
    cout << i << endl;
}
```
使用基于范围的 for 语句改变字符串中的字符
```cpp
std::string s("abcd");
for (auto &i : s)
{
    i = '1';
}
```

## 标准库类型 vector
`vector` 也称为容器（container），表示对象的集合。要想是用 vector，必须包含适当的头文件：
```cpp
#include <vector>
using std::vector;
```
C++ 既有类模板（class template）也有函数模板，其中 vector 是一个类模板。模板不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。

编译器根据模板创建类或函数的过程称为实例化（instantiation），当使用模板时，需要指出编译器应把类或函数实例化为何种类型。
```cpp
vector<char> s;
vector<int> i;
vector<vector<string>> vs;
```
### 定义和初始化 vector 对象
### 向 vector 对象添加元素
### 其他 vector 操作

## 迭代器介绍
## 数组
## 多维数组