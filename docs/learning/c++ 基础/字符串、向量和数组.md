本章将介绍两种重要的标准库类型 `string` 和 `vector`：
- string：表示可变长的字符序列
- vector：存放某种给定类型对象的可变长序列
- 数组：数组的实现与硬件密切相关，string 和 vector 都是对它的某种抽象，但其灵活性稍有不足
- 迭代器：是 string 和 vector 的配套类型，常被用于访问 string 中的字符或 vector 中的元素
## 命名空间的 using 声明
作用域操作符（::）的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。
```cpp
#include <iostream>
std::string a; // 使用命名空间 std 的中名字 string
```
### using 声明（using declaration）
- 形式：`using namespace::name`
- 无须专门的前缀（namespace::name）也能使用所需的名字
- 每个名字都需要独立的 using 声明：
  ```cpp
  #include <iostream>
  // 一行可以放多条 using 声明语句，但每个名字都必须有自己的 using 声明语句，以分号结束
  using std::cout; using std::endl; 
  using std::string;
  int main()
  {
      string a = "str";
      cout << a << endl;
      return 1;
  }
  ```
### 头文件不应包含 using 声明语句
头文件的内容会被拷贝到所有包含它的文件中去，如果头文件里有某个 using 声明，那么每个使用该头文件的文件都会有这个声明。由于不经意间包含了一些名字，反而可以产生始料未及的名字冲突。
## 标准库类型 string
使用 `string` 类型必须包含 string 头文件，作为标准库的一部分，string 定义在命名空间 std 中：
```cpp
#include <string>
using std::string;
```
### 定义和初始化
| 初始化方式          | 含义                                                    |
| ------------------- | :------------------------------------------------------ |
| string s1           | 默认初始化，s1是一个空字符串                            |
| string s2(s1)       | s2是s1的副本                                            |
| string s2 = s1      | 等价于 s2(s1)                                           |
| string s3("value)   | s3是字面值"value"的副本，除了字面值最后的那个空字符串外 |
| string s3 = "value" | 等价于s3("value")                                       |
| string s4(n,'c')    | 把s4初始化为由连续n个字符'c'组成的串                    |
直接初始化和拷贝初始化：
- 拷贝初始化（copy initialization）：使用等号（=）初始化一个变量
- 直接初始化（direct initialization）：不使用等号初始化
### string 对象上的操作

| 操作             | 含义                                       |
| ---------------- | :----------------------------------------- |
| `os << s`        | 将s写到输出流os当中，返回os                |
| `is >> s`        | 从输入流is读取字符赋给s，返回is            |
| `getline(is, s)` | 从输入流is读取一行赋给s，返回is            |
| `s.empty()`      | s为空返回true，否则返回false               |
| `s.size()`       | 返回s中字符的个数                          |
| `s[n]`           | 返回s中第n个字符的引用                     |
| `s1 + s2`        | 返回s1和s2连接后的结果                     |
| `s1 = s2`        | 用s2的副本替代s1原来的字符                 |
| `s1 == s2`       | 判断s1和s2所含的字符是否完全一样           |
| `s1 != s2`       | 对大小写敏感                               |
| `<, <=, >, >=`   | 利用字符在字典中的顺序进行比较，大小写敏感 |
读写 string 对象
- 执行读写操作时，`string` 对象会自动忽略开头的空白并从第一个真的的字符开始读起，知道遇见下一处空白：
  ```cpp
  string s;
  cin >> s;
  cout << s << std::endl;
  ```
  如果程序输入是“    HELLO WORLD    ”，则输出将是“HELLO”，输出结果没有包含任何空格。

  和内置类型的输入输出一样，string 对象的此类操作也是返回操作符左侧的运算对象作为其结果：
  ```cpp
  string s1, s2;
  cin >> s1 >> s2;
  cout << s1 << s2 << std::endl;
  ```
  如果程序输入是“    HELLO WORLD    ”，则输出将是“HELLOWORLD”。
- 读取未知数量的 string 对象：
  ```cpp
  string s, tmp;
  while (cin >> tmp)
  {
      s += tmp;
  }
  cout << s << std::endl;
  ```

- 如果希望在最终的字符串中保留输入时的空格符，这时应使用 `getline`
  ```cpp
  string s, tmp;
  while (std::getline(std::cin, tmp))
  {
      s += tmp;
      s += "\n";
  }

  std::cout << s << std::endl;
  ```
  `getline` 函数接收一个输入流和一个 `string` 对象，函数从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来），然后把读取的内容存入 `string` 对象中（注意不存换行符）。

string 的 empty 和 size 操作：
- empty：`string` 的一个成员函数，根据 `string` 对象是否为空返回一个对应的布尔值。
- size：返回 string 对象的长度
- string::size_type：`string` 类及其他大多数标准库类型定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性，`string::size_type` 即是其中的一种。`string::size_type` 是一个无符号类型的值而且足够存放下任何 `string` 对象的大小。所有用于存放 `string` 类的 `size` 函数返回值的变量，都应该是 `string::size_type` 类型的。
  ::: tip
  如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。如果一条表达式中已经有了 `size` 函数，就不要再使用 `int`，这样可以避免混用 `int` 和 `unsigned` 可能带来的问题。
  :::
比较 string 对象
- 相等性运算符（== 和 !=）：比较两个 `string` 对象是否长度相等且所包含的字符也全部相同。
- <、<=、>、>=：
  - 如果两个 `string` 对象的长度不通，而且较短 `string` 对象的每个字符都与较长 `string` 对象对应位置上的字符相同，就说较短 `string` 对象小于较长 `string` 对象。
  - 如果 string 对象在某些对应位置上不一致，则 string 对象比较的结果其实就是 string 对象中第一对相异字符比较的结果。
字面值和 string 对象相加

标准库允许将字符字面值与字符串字面值转化成 string 对象，所以在需要 string 对象的地方就可以使用这两种字面量来代替。
```cpp
string s;
s+='a';
s+='b';
std::cout << s << std::endl;
```
::: tip
当把 string 对象和字符字面量及字符串字面量混在一条语句中使用时，必须确保加法运算符（+）的两侧运算对象至少有一个是 string 对象。
```cpp
string s = "";
string s1 = s + "hello" + "world"; // 正确
string s2 = "hello" + "world" + 2; // 错误
```
切记：c++ 语言中的字符串字面量并不是标准库类型 string 的对象，字符串字面量与 string 对象是不同的类型。
:::
### 处理 string 对象中的字符
cctype 头文件中的函数
|   函数   |          含义          |
| :------: | :--------------------: |
| isalnum  |       数字或字母       |
| isalpha  |          数字          |
| isdigit  |          字母          |
| isxdigit |      十六进制数字      |
| isprint  | 可打印：空格、可使形式 |
| isspace  |     空格、空白字符     |
| isgraph  |      非空白可打印      |
| iscntrl  |        控制字符        |
| ispunct  |        标点符号        |
| islower  |        小写字母        |
| isupper  |        大写字母        |
| tolower  |                        |
| toupper  |                        |
::: tip
C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 `name.h`，C++ 则将这些文件命名为 `cname`。 
`cctype` 头文件和 `ctype.h` 头文件的内容是一样的，只不过从命名规范上更复合 C++ 语言的要求。在 `cname` 头文件定义的名字从属于命名空间 `std`，而定义在 `name.h` 中的则不然。
:::
处理每个字符？使用基于范围的 for 语句
```cpp
for (auto i : "abcd")
{
    cout << i << endl;
}
```
使用基于范围的 for 语句改变字符串中的字符
```cpp
std::string s("abcd");
for (auto &i : s)
{
    i = '1';
}
```

## 标准库类型 vector
`vector` 也称为容器（container），表示对象的集合。要想是用 vector，必须包含适当的头文件：
```cpp
#include <vector>
using std::vector;
```
C++ 既有类模板（class template）也有函数模板，其中 vector 是一个类模板。模板不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。

编译器根据模板创建类或函数的过程称为实例化（instantiation），当使用模板时，需要指出编译器应把类或函数实例化为何种类型。
```cpp
vector<char> s;
vector<int> i;
vector<vector<string>> vs;
```
`vector` 能容纳绝大多数类型的对象最为其元素，但是因为引用不是对象，所以不存在包含引用的 `vector`。

在早期 C++ 标准中，如果 `vector` 的元素还是 `vector`，则其定义的形式与现在的 C++11 新标准略有不同。
```cpp
vector<vector<int> > v1; // 在外层 vector 对象的右尖括号和其元素之间添加一个空格，某些编译器仍需要
vector<vector<int>> v2; // 新标准定义形式
```
### 定义和初始化 vector 对象
| 初始化形式                    | 含义                                                        |
| :---------------------------- | :---------------------------------------------------------- |
| `vector<T> v1`                | v1 是一个执行默认初始化的空 vector，其潜在的元素是 T 类型的 |
| `vector<T> v2(v1)`            | v2 中包含了 v1 所有元素的副本                               |
| `vector<T> v2 = v1`           | 等价于 `v2(v1)`                                             |
| `vector<T> v3(n, val)`        | v3 包含了 n 个重复的元素，每个元素的值都是 val              |
| `vector<T> v4(n)`             | v4 包含了 n 个重复的执行了值初始化的对象                    |
| `vector<T> v5{a, b, c...}`    | v5 包含了初始值数量的元素，每个元素被赋予对应的初始值       |
| `vector<T> v5 = {a, b, c...}` | 等价于 v5{a, b, c...}                                       |

- 列表初始化 vector 对象
  
  C++ 语言提供了几种不同的[初始化方式](../c++&#32;基础/变量和基础类型.md#_2-2-变量)，在大多数情况下这些初始化方式可以相互等价地使用。例外情况：
  - 使用[拷贝初始化](#标准库类型-string)时（即使用 = 时），只能提供一个初始值
  - 如果提供一个[类内初始值](变量和基础类型.html#_2-6-1)，则只能使用拷贝初始化或者使用花括号的形式初始化。
  - 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里面进行列表初始化，而不能放在圆括号里。
- 值初始化：如果只提供 vector 对象容纳的元素数量而不提供初始值，此时库会创建一个值初始化的（value-initialized）的元素初值，并把它赋给容器的所有元素。这个初值由 vector 对象中的类型决定：
  - 内置类型：比如 `int`，则元素初始值自动设为 0。
  - 类类型：比如 `string`，则元素由类默认初始化。

  对于这种初始化的方式有两个特殊的限制：
    - 如果 vector 对象中的元素不支持默认初始化，我们就必须提供初始的元素的值。
    - 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化（而不是拷贝初始化）
    ```cpp
    vector<int> vi = 10; // 必须使用直接初始化的形式指定向量大小
    ```
- 列表初始值还是元素数量？
```cpp
vector<int> v1(10); // 10个值都是0的元素
vector<int> v2{10}; // 1个值是10的元素
vector<int> v3(10, 1); // 10个值都是1的元素
vector<int> v4{10, 1}; // 2个值分别是10和1的元素
```
  - 如果用的是圆括号，可以说提供的值是用来构造 `vector` 对象的。
  - 如果用的是花括号：
    - 提供的值满足执行列表初始化时，将花括号的值当作元素初始值的列表来处理
    - 无法执行列表初始化时，将花括号的值用来构造 `vector` 对象
### 向 vector 对象添加元素
### 其他 vector 操作

## 迭代器介绍
## 数组
## 多维数组