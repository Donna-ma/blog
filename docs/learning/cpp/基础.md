# 变量和基础类型
## 基本内置类型
## 变量
## 复合类型
### 引用
引用（reference）为对象起了另一个名字，引用类型引用（refer to）另外一种类型。通过将声明符写成 `&d` 的形式来定义引用类型，其中 `d` 是声明的变量名。

一般在初始化时，初始值会被拷贝到新建的对象中。而在定义引用时，程序把引用和初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，无法将引用重新绑定到另外一个对象，因此引用必须初始化。
```cpp
int i = 1;
// d 和 i 绑定到一起，即 d 是 i 的另一个名字
int &d = i;
// 报错：引用必须初始化
int &r;
```
#### 引用即别名
定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。
- 为引用赋值，实际上是将值赋给与之绑定的对象
- 获取引用的值，实际上是获取与之绑定对象的值

引用本身不是一个对象，所以无法定义引用的引用。
#### 引用的定义
允许一条语句中定义多个引用，其中每个标识符都必须以符号 `&` 开头：
```cpp
int i = 1;
int &r1 = i,&r2 = r1;
```
引用只能绑定到对象上，不能绑定与字面量或某个表达式的计算结果绑定在一起。
```cpp
int i;
int &r1 = i + 1; // 报错：非常量引用的初始值必须为左值
int &r2 = 1; // 报错：非常量引用的初始值必须为左值
```
::: tip
为什么 ?
:::
引用的类型必须和与之绑定的对象严格匹配，除了以下两种情况？55/534
1. 定义常量引用时，允许任意表达式作为初始值，只要该表达式的结果能装换成引用的类型即可。
  ```cpp
  int i;
  const int &r1 = i + 1;
  const int &r2 = 1;
  ```
2. 我们可以将基类的指针或引用绑定到派生类对象上
### 指针
指针（pointer）是指向（point to）另外一种类型的复合类型。与引用比较：
- 相同：都实现了对其他对象的间接访问
- 不同：
  - 指针是一个对象，可以对其赋值和拷贝。在指针生命周期内，它可以指向不同的对象。
  - 指针定义时无需初始化，在块级作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。

将声明符写成 `*d` 的形式来定义指针，允许一条语句中定于多个指针，其中每个标识符都必须已 `*` 开头。
```cpp
int *p1, i2; //
```
#### 获取对象的地址
指针存放某个对象的地址，想要获取该地址，需要使用取地址符 `&`。
```cpp
int i = 0;
int *p = &i; // p 存放变量 i 的地址
```
因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了以下两种情况，其他所有的指针的类型都必须和它所指向的对象严格匹配：
1. 允许一个常量指针指向一个非常量对象
2. 我们可以将基类的指针或引用绑定到派生类对象上
#### 指针值
指针的值（即地址）应属于下列四个状态之一：
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针不指向任何对象
4. 无效指针，也就是上述情况之外的其他值

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果是无法预计的，因此程序员必须清楚任意给定的指针是否有效。

经过第 2、3 种指针是有效的，但其使用同样收到限制。显然这类指针并未指向任何具体对象，所以访问这类指针（假定的）对象是不被允许的。如果这样做了，后果也无法预计。
#### 利用指针访问对象
如果指针指向了一个对象，则允许使用解引用符 `*` 来访问该对象。
```cpp
int i = 0, *p = i;
*p = 2;
```
#### 空指针
空指针（null pointer）不指向任何对象，以下列出几个生成空指针的方法：
```cpp
int *p1 = nullptr; // C++11 标准，等价 int *p1 = 0;
int *p2 = 0;
// 需要先 #include "cstdlib"
int *p3 = NULL; // NULL 是 cstdlib 头文件中定义的预处理变量，它的值是 0
```
#### void* 指针
`void*` 指针是一种特殊的指针，可用于存放任意对象的地址，但是对该地址存放的是什么类型的对象并不了解。

void指针能做的事有限：拿它和别的指针比较、作为函数的输入和输出、或者赋值给另外一个void指针，但是我们不能操作 `void*` 指针所指向的对象。
### 理解复合类型的声明
#### 定义多个复合类型变量
```cpp
int i=0, &r = i, *p = &r;
```
#### 指向指针的指针
```cpp
int i=0, *p=&i,**pp = &p; // pp 是指向指针 p 的指针
```
## const 限定符
const 对象一旦创建后其值不能再改变，所以 const 对象必须初始化。初始值可以是任意复杂的表达式。
```cpp
int fn()
{
  return 1;
}
const int i = fn();
```
可以将 const 对象拷贝给非 const 对象，一旦拷贝完成，新的对象和原来的对象就没有什么关系了

::: tip 默认情况下，const 对象仅对文件内有效。
当以编译时初始化的方式定义一个 const 对象时，编译器将在编译过程将用到该对象的地方替换成对应值。为此，编译器必须知道 const 变量的初始值，每个用到 const 对象的文件都必须得能访问到它的初始值才行，每个用到 const 变量的文件都必须有对它的定义。默认情况下，const 对象被设定为仅在文件内有效，当多个文件出现了同名的 const 变量时，等同于在不同文件中分别定义了独立的变量。有时，我们希望在一个文件中定义 const 变量，并在多个文件中声明并使用它，这时我们需要在 const 变量定义和声明的地方添加 `extern` 关键字：
```cpp
// c.h
extern const int i;

// c.cpp
int fn()
{
  return 1;
}
extern const int i = fn();
```
:::
### 默认情况下
## 处理类型
## 自定义数据类型
