# 变量和基础类型
## 基本内置类型
## 变量
## 复合类型
### 引用
引用（reference）为对象起了另一个名字，引用类型引用（refer to）另外一种类型。通过将声明符写成 `&d` 的形式来定义引用类型，其中 `d` 是声明的变量名。

一般在初始化时，初始值会被拷贝到新建的对象中。而在定义引用时，程序把引用和初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，无法将引用重新绑定到另外一个对象，因此引用必须初始化。
```cpp
int i = 1;
// d 和 i 绑定到一起，即 d 是 i 的另一个名字
int &d = i;
// 报错：引用必须初始化
int &r;
```
#### 引用即别名
定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。
- 为引用赋值，实际上是将值赋给与之绑定的对象
- 获取引用的值，实际上是获取与之绑定对象的值

引用本身不是一个对象，所以无法定义引用的引用。
#### 引用的定义
允许一条语句中定义多个引用，其中每个标识符都必须以符号 `&` 开头：
```cpp
int i = 1;
int &r1 = i,&r2 = r1;
```
引用只能绑定到对象上，不能绑定与字面量或某个表达式的计算结果绑定在一起。
```cpp
int i;
int &r1 = i + 1; // 报错：非常量引用的初始值必须为左值
int &r2 = 1; // 报错：非常量引用的初始值必须为左值
```
::: tip
为什么 ?
:::
引用的类型必须和与之绑定的对象严格匹配，除了以下两种情况？55/534
1. 定义常量引用时，允许任意表达式作为初始值，只要该表达式的结果能装换成引用的类型即可。
  ```cpp
  int i;
  const int &r1 = i + 1;
  const int &r2 = 1;
  ```
2. 我们可以将基类的指针或引用绑定到派生类对象上
### 指针
指针（pointer）是指向（point to）另外一种类型的复合类型。与引用比较：
- 相同：都实现了对其他对象的间接访问
- 不同：
  - 指针是一个对象，可以对其赋值和拷贝。在指针生命周期内，它可以指向不同的对象。
  - 指针定义时无需初始化，在块级作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。

将声明符写成 `*d` 的形式来定义指针，允许一条语句中定于多个指针，其中每个标识符都必须已 `*` 开头。
```cpp
int *p1, i2; //
```
#### 获取对象的地址
指针存放某个对象的地址，想要获取该地址，需要使用取地址符 `&`。
```cpp
int i = 0;
int *p = &i; // p 存放变量 i 的地址
```
因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了以下两种情况，其他所有的指针的类型都必须和它所指向的对象严格匹配：
1. 允许一个常量指针指向一个非常量对象
2. 我们可以将基类的指针或引用绑定到派生类对象上
#### 指针值
指针的值（即地址）应属于下列四个状态之一：
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针不指向任何对象
4. 无效指针，也就是上述情况之外的其他值

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果是无法预计的，因此程序员必须清楚任意给定的指针是否有效。

经过第 2、3 种指针是有效的，但其使用同样收到限制。显然这类指针并未指向任何具体对象，所以访问这类指针（假定的）对象是不被允许的。如果这样做了，后果也无法预计。
#### 利用指针访问对象
如果指针指向了一个对象，则允许使用解引用符 `*` 来访问该对象。
```cpp
int i = 0, *p = i;
*p = 2;
```
### 理解复合类型的声明
## const 限定符
## 处理类型
## 自定义数据类型
